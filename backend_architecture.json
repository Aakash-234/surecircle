{
  "structure": {
    "package.json": {
      "name": "sure-circle-backend",
      "version": "1.0.0",
      "description": "Backend API for Sure Circle P2P Insurance Platform",
      "main": "server.js",
      "scripts": {
        "start": "node server.js",
        "dev": "nodemon server.js",
        "test": "jest",
        "migrate": "npx sequelize-cli db:migrate",
        "seed": "npx sequelize-cli db:seed:all"
      },
      "dependencies": {
        "express": "^4.18.2",
        "cors": "^2.8.5",
        "helmet": "^7.0.0",
        "morgan": "^1.10.0",
        "dotenv": "^16.0.3",
        "bcryptjs": "^2.4.3",
        "jsonwebtoken": "^9.0.1",
        "mongoose": "^7.4.0",
        "multer": "^1.4.5",
        "socket.io": "^4.7.2",
        "nodemailer": "^6.9.4",
        "express-rate-limit": "^6.8.1",
        "express-validator": "^7.0.1",
        "compression": "^1.7.4",
        "winston": "^3.10.0",
        "@tensorflow/tfjs-node": "^4.9.0",
        "razorpay": "^2.8.6",
        "aws-sdk": "^2.1422.0",
        "redis": "^4.6.7"
      },
      "devDependencies": {
        "nodemon": "^3.0.1",
        "jest": "^29.6.1",
        "supertest": "^6.3.3"
      }
    }
  },
  "server_code": "\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst mongoose = require('mongoose');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst rateLimit = require('express-rate-limit');\nconst compression = require('compression');\nrequire('dotenv').config();\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server, {\n    cors: {\n        origin: process.env.FRONTEND_URL || \"http://localhost:3000\",\n        methods: [\"GET\", \"POST\"]\n    }\n});\n\n// Import routes\nconst authRoutes = require('./routes/auth');\nconst userRoutes = require('./routes/users');\nconst poolRoutes = require('./routes/pools');\nconst claimRoutes = require('./routes/claims');\nconst paymentRoutes = require('./routes/payments');\nconst trustScoreRoutes = require('./routes/trustScore');\nconst notificationRoutes = require('./routes/notifications');\n\n// Import middleware\nconst { authenticateToken } = require('./middleware/auth');\nconst errorHandler = require('./middleware/errorHandler');\nconst logger = require('./utils/logger');\n\n// Security middleware\napp.use(helmet());\napp.use(cors({\n    origin: process.env.FRONTEND_URL || \"http://localhost:3000\",\n    credentials: true\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100, // limit each IP to 100 requests per windowMs\n    message: 'Too many requests from this IP, please try again later.'\n});\napp.use('/api/', limiter);\n\n// Body parsing middleware\napp.use(compression());\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true }));\n\n// Logging\napp.use(morgan('combined', { stream: { write: message => logger.info(message.trim()) } }));\n\n// Database connection\nmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/surecircle', {\n    useNewUrlParser: true,\n    useUnifiedTopology: true\n}).then(() => {\n    logger.info('Connected to MongoDB');\n}).catch(err => {\n    logger.error('MongoDB connection error:', err);\n});\n\n// Socket.io for real-time features\nio.on('connection', (socket) => {\n    logger.info('User connected:', socket.id);\n\n    socket.on('join-pool', (poolId) => {\n        socket.join(`pool-${poolId}`);\n        logger.info(`User ${socket.id} joined pool ${poolId}`);\n    });\n\n    socket.on('disconnect', () => {\n        logger.info('User disconnected:', socket.id);\n    });\n});\n\n// Make io accessible to routes\napp.set('io', io);\n\n// API Routes\napp.use('/api/auth', authRoutes);\napp.use('/api/users', authenticateToken, userRoutes);\napp.use('/api/pools', authenticateToken, poolRoutes);\napp.use('/api/claims', authenticateToken, claimRoutes);\napp.use('/api/payments', authenticateToken, paymentRoutes);\napp.use('/api/trust-score', authenticateToken, trustScoreRoutes);\napp.use('/api/notifications', authenticateToken, notificationRoutes);\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n    res.json({ \n        status: 'healthy', \n        timestamp: new Date().toISOString(),\n        uptime: process.uptime()\n    });\n});\n\n// Error handling middleware\napp.use(errorHandler);\n\n// 404 handler\napp.use('*', (req, res) => {\n    res.status(404).json({ error: 'Route not found' });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => {\n    logger.info(`Server running on port ${PORT}`);\n});\n\nmodule.exports = app;\n",
  "trust_score_service": "\nconst tf = require('@tensorflow/tfjs-node');\nconst User = require('../models/User');\nconst Contribution = require('../models/Contribution');\nconst Claim = require('../models/Claim');\nconst ClaimVote = require('../models/ClaimVote');\nconst logger = require('../utils/logger');\n\nclass TrustScoreService {\n    constructor() {\n        this.model = null;\n        this.scaler = null;\n        this.featureNames = [\n            'payment_consistency', 'contribution_frequency', 'payment_amount_stability',\n            'claim_frequency', 'claim_legitimacy', 'claim_amount_reasonableness',\n            'voting_participation', 'referral_activity', 'group_tenure',\n            'kyc_completeness', 'document_quality',\n            'peer_ratings', 'network_trust', 'dispute_history'\n        ];\n\n        this.scoreBands = {\n            'Excellent': [800, 900],\n            'Very Good': [750, 799],\n            'Good': [700, 749],\n            'Fair': [650, 699],\n            'Poor': [300, 649]\n        };\n    }\n\n    async loadModel() {\n        try {\n            // In production, load from saved model file\n            // this.model = await tf.loadLayersModel('file://./models/trust-score-model.json');\n            logger.info('Trust score model loaded successfully');\n        } catch (error) {\n            logger.error('Error loading trust score model:', error);\n        }\n    }\n\n    async calculateTrustScore(userId) {\n        try {\n            const user = await User.findById(userId);\n            if (!user) {\n                throw new Error('User not found');\n            }\n\n            // Gather user data\n            const userData = await this.gatherUserData(userId);\n\n            // Extract features\n            const features = await this.extractFeatures(userData);\n\n            // Calculate score (mock calculation for demo)\n            const rawScore = this.mockPrediction(features);\n            const trustScore = Math.max(300, Math.min(900, Math.round(rawScore)));\n\n            // Determine score band\n            const scoreBand = this.getScoreBand(trustScore);\n\n            // Calculate factor contributions\n            const factors = this.calculateFactorContributions(features);\n\n            // Save to database\n            await this.saveTrustScore(userId, trustScore, factors);\n\n            return {\n                trustScore,\n                scoreBand,\n                factors: factors.slice(0, 5), // Top 5 factors\n                lastUpdated: new Date(),\n                confidence: Math.random() * 0.25 + 0.75 // 75-100% confidence\n            };\n\n        } catch (error) {\n            logger.error('Error calculating trust score:', error);\n            throw error;\n        }\n    }\n\n    async gatherUserData(userId) {\n        // Gather all relevant user data\n        const [user, contributions, claims, votes] = await Promise.all([\n            User.findById(userId),\n            Contribution.find({ user_id: userId }),\n            Claim.find({ claimant_id: userId }),\n            ClaimVote.find({ voter_id: userId })\n        ]);\n\n        const monthsActive = this.calculateMonthsActive(user.created_at);\n        const onTimeContributions = contributions.filter(c => c.status === 'successful').length;\n        const approvedClaims = claims.filter(c => c.status === 'approved').length;\n\n        return {\n            user,\n            contributions,\n            claims,\n            votes,\n            monthsActive,\n            onTimeContributions,\n            approvedClaims\n        };\n    }\n\n    extractFeatures(userData) {\n        const { user, contributions, claims, votes, monthsActive, onTimeContributions, approvedClaims } = userData;\n\n        const features = {\n            payment_consistency: onTimeContributions / Math.max(contributions.length, 1),\n            contribution_frequency: contributions.length / Math.max(monthsActive, 1),\n            payment_amount_stability: this.calculatePaymentStability(contributions),\n            claim_frequency: claims.length / Math.max(monthsActive, 1),\n            claim_legitimacy: approvedClaims / Math.max(claims.length, 1),\n            claim_amount_reasonableness: this.calculateClaimReasonableness(claims),\n            voting_participation: votes.length / Math.max(monthsActive * 2, 1),\n            referral_activity: Math.min((user.successful_referrals || 0) / 10, 1),\n            group_tenure: Math.min(monthsActive / 24, 1),\n            kyc_completeness: user.kyc_status === 'verified' ? 1 : 0,\n            document_quality: user.document_verification_score || 0.5,\n            peer_ratings: (user.avg_peer_rating || 3.0) / 5.0,\n            network_trust: Math.min((user.trusted_connections || 0) / 20, 1),\n            dispute_history: 1 - Math.min((user.disputes_raised || 0) / 5, 1)\n        };\n\n        return Object.values(features);\n    }\n\n    mockPrediction(features) {\n        // Mock ML prediction - in production, use actual trained model\n        let score = 600; // Base score\n\n        // Payment consistency (most important factor)\n        score += features[0] * 150;\n\n        // KYC completion\n        score += features[9] * 50;\n\n        // Voting participation\n        score += features[6] * 80;\n\n        // Add some randomness\n        score += (Math.random() - 0.5) * 40;\n\n        return score;\n    }\n\n    getScoreBand(score) {\n        for (const [band, [min, max]] of Object.entries(this.scoreBands)) {\n            if (score >= min && score <= max) {\n                return band;\n            }\n        }\n        return 'Poor';\n    }\n\n    calculateFactorContributions(features) {\n        const contributions = this.featureNames.map((name, index) => ({\n            factor: name,\n            value: features[index],\n            impact: features[index] * (Math.random() * 20 + 5) // Mock impact calculation\n        }));\n\n        return contributions.sort((a, b) => b.impact - a.impact);\n    }\n\n    calculateMonthsActive(joinDate) {\n        const now = new Date();\n        const joined = new Date(joinDate);\n        return Math.max(1, Math.round((now - joined) / (1000 * 60 * 60 * 24 * 30)));\n    }\n\n    calculatePaymentStability(contributions) {\n        if (contributions.length < 2) return 1;\n\n        const amounts = contributions.map(c => c.amount);\n        const mean = amounts.reduce((a, b) => a + b, 0) / amounts.length;\n        const variance = amounts.reduce((sum, amount) => sum + Math.pow(amount - mean, 2), 0) / amounts.length;\n        const stdDev = Math.sqrt(variance);\n\n        return Math.max(0, 1 - (stdDev / mean));\n    }\n\n    calculateClaimReasonableness(claims) {\n        if (claims.length === 0) return 1;\n\n        const avgAmount = claims.reduce((sum, claim) => sum + claim.amount_requested, 0) / claims.length;\n        const reasonableAmount = 25000; // Threshold for reasonable claims\n\n        return Math.max(0, 1 - (avgAmount / reasonableAmount));\n    }\n\n    async saveTrustScore(userId, score, factors) {\n        const TrustScore = require('../models/TrustScore');\n\n        const trustScoreRecord = new TrustScore({\n            user_id: userId,\n            score: score,\n            factors: factors,\n            calculated_at: new Date()\n        });\n\n        await trustScoreRecord.save();\n\n        // Update user's current trust score\n        await User.findByIdAndUpdate(userId, { trust_score: score });\n    }\n}\n\nmodule.exports = new TrustScoreService();\n",
  "api_routes": {
    "auth.js": "\nconst express = require('express');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst { body, validationResult } = require('express-validator');\nconst User = require('../models/User');\nconst router = express.Router();\n\n// Register\nrouter.post('/register', [\n    body('email').isEmail().normalizeEmail(),\n    body('password').isLength({ min: 6 }),\n    body('name').trim().notEmpty(),\n    body('phone').isMobilePhone('en-IN')\n], async (req, res) => {\n    try {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({ errors: errors.array() });\n        }\n\n        const { email, password, name, phone } = req.body;\n\n        // Check if user exists\n        const existingUser = await User.findOne({ \n            $or: [{ email }, { phone }] \n        });\n\n        if (existingUser) {\n            return res.status(400).json({ \n                error: 'User already exists with this email or phone' \n            });\n        }\n\n        // Hash password\n        const hashedPassword = await bcrypt.hash(password, 12);\n\n        // Create user\n        const user = new User({\n            email,\n            password: hashedPassword,\n            name,\n            phone,\n            trust_score: 650 // Initial score\n        });\n\n        await user.save();\n\n        // Generate JWT\n        const token = jwt.sign(\n            { userId: user._id },\n            process.env.JWT_SECRET,\n            { expiresIn: '24h' }\n        );\n\n        res.status(201).json({\n            token,\n            user: {\n                id: user._id,\n                email: user.email,\n                name: user.name,\n                trust_score: user.trust_score\n            }\n        });\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\n// Login\nrouter.post('/login', [\n    body('email').isEmail().normalizeEmail(),\n    body('password').notEmpty()\n], async (req, res) => {\n    try {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({ errors: errors.array() });\n        }\n\n        const { email, password } = req.body;\n\n        // Find user\n        const user = await User.findOne({ email });\n        if (!user) {\n            return res.status(401).json({ error: 'Invalid credentials' });\n        }\n\n        // Check password\n        const isValidPassword = await bcrypt.compare(password, user.password);\n        if (!isValidPassword) {\n            return res.status(401).json({ error: 'Invalid credentials' });\n        }\n\n        // Generate JWT\n        const token = jwt.sign(\n            { userId: user._id },\n            process.env.JWT_SECRET,\n            { expiresIn: '24h' }\n        );\n\n        res.json({\n            token,\n            user: {\n                id: user._id,\n                email: user.email,\n                name: user.name,\n                trust_score: user.trust_score,\n                kyc_status: user.kyc_status\n            }\n        });\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\nmodule.exports = router;\n    ",
    "pools.js": "\nconst express = require('express');\nconst { body, validationResult } = require('express-validator');\nconst Pool = require('../models/Pool');\nconst PoolMember = require('../models/PoolMember');\nconst router = express.Router();\n\n// Get all pools (with pagination)\nrouter.get('/', async (req, res) => {\n    try {\n        const page = parseInt(req.query.page) || 1;\n        const limit = parseInt(req.query.limit) || 10;\n        const skip = (page - 1) * limit;\n\n        const pools = await Pool.find({ status: 'active' })\n            .skip(skip)\n            .limit(limit)\n            .populate('created_by', 'name')\n            .sort({ created_at: -1 });\n\n        const total = await Pool.countDocuments({ status: 'active' });\n\n        res.json({\n            pools,\n            pagination: {\n                current: page,\n                pages: Math.ceil(total / limit),\n                total\n            }\n        });\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\n// Create new pool\nrouter.post('/', [\n    body('name').trim().notEmpty(),\n    body('description').trim().notEmpty(),\n    body('category').notEmpty(),\n    body('monthly_contribution').isNumeric(),\n    body('coverage_limit').isNumeric(),\n    body('max_members').isInt({ min: 3, max: 50 })\n], async (req, res) => {\n    try {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({ errors: errors.array() });\n        }\n\n        const pool = new Pool({\n            ...req.body,\n            created_by: req.user.userId\n        });\n\n        await pool.save();\n\n        // Add creator as first member\n        const member = new PoolMember({\n            pool_id: pool._id,\n            user_id: req.user.userId,\n            role: 'admin'\n        });\n\n        await member.save();\n\n        res.status(201).json(pool);\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\n// Join pool\nrouter.post('/:poolId/join', async (req, res) => {\n    try {\n        const { poolId } = req.params;\n\n        // Check if pool exists and is active\n        const pool = await Pool.findById(poolId);\n        if (!pool || pool.status !== 'active') {\n            return res.status(404).json({ error: 'Pool not found or inactive' });\n        }\n\n        // Check if already a member\n        const existingMember = await PoolMember.findOne({\n            pool_id: poolId,\n            user_id: req.user.userId\n        });\n\n        if (existingMember) {\n            return res.status(400).json({ error: 'Already a member of this pool' });\n        }\n\n        // Check if pool is full\n        const memberCount = await PoolMember.countDocuments({ \n            pool_id: poolId, \n            status: 'active' \n        });\n\n        if (memberCount >= pool.max_members) {\n            return res.status(400).json({ error: 'Pool is full' });\n        }\n\n        // Add member\n        const member = new PoolMember({\n            pool_id: poolId,\n            user_id: req.user.userId,\n            role: 'member'\n        });\n\n        await member.save();\n\n        // Emit real-time notification\n        const io = req.app.get('io');\n        io.to(`pool-${poolId}`).emit('member-joined', {\n            poolId,\n            memberId: req.user.userId\n        });\n\n        res.status(201).json({ message: 'Successfully joined pool' });\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\nmodule.exports = router;\n    "
  }
}